# 闭包的理解

## 1. 基本知识

**作用域**

在JavaScript中执行某个函数时，如果遇见变量且需要读取其值，就会“就近”先在函数内部查找该变量的声明或赋值情况。如果在函数内无法找到该变量，就要跳出函数作用域，到更上层作用域中查找。更上层作用域也可以顺着作用域范围向外扩散，一直到全局作用域。

**作用域链**

变量作用域的查找是一个扩散的过程，就像各个环节相扣的链条，逐次递进，这就是“作用域链”的由来。

**块级作用域和暂时性死区**

使用let或const声明变量时会针对这个变量形成一个封闭的块级作用域，在这个块级作用域中，如果在声明变量前访问该变量，就会报referenceError错误；如果在声明变量后访问该变量，则可以正常获取变量。

```js
function foo() {
  console.log(bar)
  var bar = 3
}
```

```js
undefined
```

执行以上代码会输出undefined，原因是在 JavaScript 中，当一个变量被声明但未被赋值时，它的默认值是 `undefined`。因此，当 `console.log(bar)` 执行时，`bar` 的值为 `undefined`。然后，在下一行代码中，`bar` 被赋值为 `3`。但这个赋值语句不会影响之前的 `console.log()` 语句，因为它已经在变量被赋值之前执行了。

使用var声明的变量会被提升至其作用域的顶部，但它的赋值不会，因此这里是undefined。

```js
function foo() {
  console.log(bar)
  let bar = 3
}
```

```js
报错：referenceError
```

在函数 `foo` 中，使用 `let` 声明了变量 `bar`。与 `var` 不同，**`let` 声明的变量不会被提升到其作用域的顶部**。所以当 `console.log(bar)` 执行时，`bar` 还没有被初始化，因此会抛出 `ReferenceError` 错误。这个错误是因为 `let` 声明的变量有一个称为“**暂时性死区**（Temporal Dead Zone，简称 TDZ）”的概念。在 TDZ 中，访问变量会抛出一个错误，直到该变量被声明和初始化。

```js
在JavaScript中，变量的声明、初始化和赋值是不同的概念，尽管它们通常在同一行代码中完成。
变量声明是指使用关键字（如 var、let 或 const）声明一个新变量。声明一个变量只是告诉JavaScript，我们有一个新的变量，并为它分配一个内存空间。
变量初始化是指在声明变量时为其赋一个初始值。如果在声明时没有赋值，变量的初始值将为undefined。
变量赋值是指将一个新值赋给变量。这可以在变量声明后的任何时候进行，而不是在声明时。赋值将覆盖变量的当前值，使其指向新的值。
```

**执行上下文和调用栈**

